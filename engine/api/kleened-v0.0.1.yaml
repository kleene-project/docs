{
  "components": {
    "responses": {},
    "schemas": {
      "Container": {
        "description": "summary description of a container",
        "properties": {
          "command": {
            "default": [],
            "description": "Command being used when starting the container",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "created": {
            "description": "When the container was created",
            "type": "string"
          },
          "env": {
            "default": [],
            "description": "List of environment variables used when the container is used. This list will be merged with environment variables defined by the image. The values in this list takes precedence if the variable is defined in both places.",
            "example": [
              "DEBUG=0",
              "LANG=da_DK.UTF-8"
            ],
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "id": {
            "description": "The id of the container",
            "type": "string"
          },
          "image_id": {
            "description": "The id of the image that this container was created from",
            "type": "string"
          },
          "jail_param": {
            "default": [],
            "description": "List of jail parameters (see jail(8) for details)",
            "example": [
              "allow.raw_sockets=true",
              "osrelease=kleenejail"
            ],
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "layer_id": {
            "description": "The id of the layer used by the container.",
            "type": "string"
          },
          "name": {
            "description": "Name of the container.",
            "type": "string"
          },
          "running": {
            "description": "whether or not the container is running",
            "type": "boolean"
          },
          "user": {
            "description": "The default user used when creating execution instances in the container.",
            "type": "string"
          }
        },
        "title": "Container",
        "type": "object",
        "x-struct": "Elixir.Kleened.API.Schemas.Container"
      },
      "ContainerConfig": {
        "properties": {
          "cmd": {
            "default": [],
            "description": "Command to execute when the container is started. If no command is specified the command from the image is used.",
            "example": [
              "/bin/sh",
              "-c",
              "ls /"
            ],
            "items": {
              "type": "string"
            },
            "nullable": true,
            "type": "array"
          },
          "env": {
            "default": [],
            "description": "List of environment variables when using the container. This list will be merged with environment variables defined by the image. The values in this list takes precedence if the variable is defined in both.",
            "example": [
              "DEBUG=0",
              "LANG=da_DK.UTF-8"
            ],
            "items": {
              "type": "string"
            },
            "nullable": true,
            "type": "array"
          },
          "image": {
            "description": "The name or id and possibly a snapshot of the image used for creating the container.\nThe parameter uses the followinge format:\n\n- `<image_id>[:@<snapshot_id>]` or\n- `<name>[:<tag>][:@<snapshot_id>]`.\n\nIf `<tag>` is omitted, `latest` is assumed.\n",
            "example": [
              "FreeBSD:13.2-STABLE",
              "FreeBSD:13.2-STABLE:@6b3c821605d4",
              "48fa55889b0f",
              "48fa55889b0f:@2028818d6f06"
            ],
            "type": "string"
          },
          "jail_param": {
            "default": [],
            "description": "List of jail parameters to use for the container.\nSee the [`jails manual page`](https://man.freebsd.org/cgi/man.cgi?query=jail) for details.\n\nA few parameters have some special behavior in Kleene:\n\n- `exec.jail_user`: If not explicitly set, the value of the `user` parameter will be used.\n- `mount.devfs`/`exec.clean`: If not explicitly set, `mount.devfs=true`/`exec.clean=true` will be used.\n\nSo, if you do not want `exec.clean` and `mount.devfs` enabled, you must actively disable them.\n",
            "example": [
              "allow.raw_sockets=true",
              "osrelease=kleenejail"
            ],
            "items": {
              "type": "string"
            },
            "nullable": true,
            "type": "array"
          },
          "mounts": {
            "default": [],
            "description": "List of files/directories/volumes on the host filesystem that should be mounted into the container.",
            "items": {
              "$ref": "#/components/schemas/MountPointConfig"
            },
            "nullable": true,
            "type": "array"
          },
          "name": {
            "description": "Name of the container. Must match `/?[a-zA-Z0-9][a-zA-Z0-9_.-]+`.",
            "nullable": true,
            "type": "string"
          },
          "user": {
            "default": "",
            "description": "User that executes the command (cmd).\nIf no user is set, the user from the image will be used, which in turn is 'root' if no user is specified there.\n\nThis parameter will be overwritten by the jail parameter `exec.jail_user` if it is set.\n",
            "nullable": true,
            "type": "string"
          }
        },
        "title": "ContainerConfig",
        "type": "object",
        "x-struct": "Elixir.Kleened.API.Schemas.ContainerConfig"
      },
      "ContainerInspect": {
        "description": "Detailed information on a container.",
        "properties": {
          "container": {
            "$ref": "#/components/schemas/Container"
          },
          "container_endpoints": {
            "description": "Endpoints of the container.",
            "items": {
              "$ref": "#/components/schemas/EndPoint"
            },
            "type": "array"
          },
          "container_mountpoints": {
            "description": "Mountpoints of the container.",
            "items": {
              "$ref": "#/components/schemas/MountPoint"
            },
            "type": "array"
          }
        },
        "title": "ContainerInspect",
        "type": "object",
        "x-struct": "Elixir.Kleened.API.Schemas.ContainerInspect"
      },
      "ContainerSummary": {
        "description": "summary description of a container",
        "properties": {
          "command": {
            "description": "Command being used when starting the container",
            "type": "string"
          },
          "created": {
            "description": "When the container was created",
            "type": "string"
          },
          "id": {
            "description": "The id of this container",
            "type": "string"
          },
          "image_id": {
            "description": "The id of the image that this container was created from",
            "type": "string"
          },
          "image_name": {
            "description": "Name of the image that this container was created from",
            "type": "string"
          },
          "image_tag": {
            "description": "Tag of the image that this container was created from",
            "type": "string"
          },
          "name": {
            "description": "Name of the container",
            "type": "string"
          },
          "running": {
            "description": "whether or not the container is running",
            "type": "boolean"
          }
        },
        "title": "ContainerSummary",
        "type": "object",
        "x-struct": "Elixir.Kleened.API.Schemas.ContainerSummary"
      },
      "ContainerSummaryList": {
        "description": "List of summarised containers.",
        "items": {
          "$ref": "#/components/schemas/ContainerSummary"
        },
        "title": "ContainerSummaryList",
        "type": "array",
        "x-struct": "Elixir.Kleened.API.Schemas.ContainerSummaryList"
      },
      "EndPoint": {
        "description": "Endpoint connecting a container to a network.",
        "properties": {
          "container": {
            "description": "ID of the container that this endpoint belongs to.",
            "type": "string"
          },
          "epair": {
            "description": "epair used for endpoint in case of a VNET network",
            "nullable": true,
            "type": "string"
          },
          "id": {
            "description": "EndPoint ID",
            "type": "string"
          },
          "ip_address": {
            "description": "IP address of the container connected to the network",
            "nullable": true,
            "type": "string"
          },
          "network": {
            "description": "Name of the network that this endpoint belongs to.",
            "type": "string"
          }
        },
        "title": "EndPoint",
        "type": "object",
        "x-struct": "Elixir.Kleened.API.Schemas.EndPoint"
      },
      "EndPointConfig": {
        "description": "Configuration of a connection between a network to a container.",
        "properties": {
          "container": {
            "description": "Name or (possibly truncated) id of the container",
            "type": "string"
          },
          "ip_address": {
            "description": "The ip(v4) address that should be assigned to the container. If this field is not set (or null) an unused ip contained in the subnet is auto-generated.",
            "example": "10.13.37.33",
            "type": "string"
          }
        },
        "required": [
          "container"
        ],
        "title": "EndPointConfig",
        "type": "object",
        "x-struct": "Elixir.Kleened.API.Schemas.EndPointConfig"
      },
      "ErrorResponse": {
        "description": "Represents an error and (possibly) its reason.",
        "example": {
          "message": "Something went wrong."
        },
        "properties": {
          "message": {
            "description": "The error message, if any.",
            "nullable": false,
            "type": "string"
          }
        },
        "required": [
          "message"
        ],
        "title": "ErrorResponse",
        "type": "object",
        "x-struct": "Elixir.Kleened.API.Schemas.ErrorResponse"
      },
      "ExecConfig": {
        "description": "Configuration of an executable to run within a container. Some of the configuration parameters will overwrite the corresponding parameters if they are defined in the container.",
        "properties": {
          "cmd": {
            "default": [],
            "description": "Command to execute whithin the container. If no command is specified the command from the container is used.",
            "example": [
              "/bin/sh",
              "-c",
              "ls /"
            ],
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "container_id": {
            "description": "Id of the container used for creating the exec instance.",
            "type": "string"
          },
          "env": {
            "default": [],
            "description": "A list of environment variables in the form `[\"VAR=value\", ...]` that is set when the command is executed.\nThis list will be merged with environment variables defined by the container.\nThe values in this list takes precedence if the variable is defined in both places.\",\n",
            "example": [
              "DEBUG=0",
              "LANG=da_DK.UTF-8"
            ],
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "tty": {
            "default": false,
            "description": "Allocate a pseudo-TTY",
            "type": "boolean"
          },
          "user": {
            "default": "",
            "description": "User that executes the command in the container. If no user is set the user from the container will be used.",
            "type": "string"
          }
        },
        "title": "ExecConfig",
        "type": "object",
        "x-struct": "Elixir.Kleened.API.Schemas.ExecConfig"
      },
      "ExecStartConfig": {
        "description": "Options for starting an execution instance.",
        "properties": {
          "attach": {
            "description": "Whether to receive output from `stdin` and `stderr`.",
            "type": "boolean"
          },
          "exec_id": {
            "description": "id of the execution instance to start",
            "type": "string"
          },
          "start_container": {
            "description": "Whether to start the container if it is not running.",
            "type": "boolean"
          }
        },
        "required": [
          "exec_id",
          "attach",
          "start_container"
        ],
        "title": "ExecStartConfig",
        "type": "object",
        "x-struct": "Elixir.Kleened.API.Schemas.ExecStartConfig"
      },
      "IdListResponse": {
        "description": "Response to an API call that returns just an Id",
        "items": {
          "type": "string"
        },
        "title": "IdListResponse",
        "type": "array",
        "x-struct": "Elixir.Kleened.API.Schemas.IdListResponse"
      },
      "IdResponse": {
        "description": "Response to an API call that returns just an Id",
        "properties": {
          "id": {
            "description": "The id of the created/modified/destroyed object.",
            "nullable": false,
            "type": "string"
          }
        },
        "required": [
          "id"
        ],
        "title": "IdResponse",
        "type": "object",
        "x-struct": "Elixir.Kleened.API.Schemas.IdResponse"
      },
      "Image": {
        "description": "the image metadata",
        "properties": {
          "buildargs": {
            "default": {},
            "description": "Object of string pairs for build-time variables. Users pass these values at build-time. Kleened uses the buildargs as the environment context for commands run via the Dockerfile RUN instruction, or for variable expansion in other Dockerfile instructions. This is not meant for passing secret values.",
            "example": {
              "JAIL_MGMT_ENGINE": "kleene",
              "USERNAME": "Stephen"
            },
            "type": "object"
          },
          "command": {
            "default": [],
            "description": "Default command used when creating a container from this image",
            "example": [
              "/bin/sh",
              "-c",
              "/bin/ls"
            ],
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "created": {
            "description": "When the image was created",
            "type": "string"
          },
          "env": {
            "default": [],
            "description": "Environment variables and their values to set before running command.",
            "example": [
              "PWD=/roo/",
              "JAIL_MGMT_ENGINE=kleene"
            ],
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "id": {
            "description": "The id of the image",
            "type": "string"
          },
          "instructions": {
            "default": [],
            "description": "Instructions and their corresponding snapshots, if any, used for creating the image.\nEach item in the array is comprised of a 2-element array of the form `[\"<instruction>\",\"<snapshot>\"]`\ncontaining a instruction and its snapshot.\nThe latter will only be present if it is a `RUN` or `COPY` instruction that executed succesfully.\nOtherwise `<snapshot>` will be an empty string.\n",
            "example": [],
            "items": {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "type": "array"
          },
          "layer_id": {
            "description": "Id of the layer containing the image",
            "type": "string"
          },
          "name": {
            "description": "Name of the image",
            "type": "string"
          },
          "tag": {
            "description": "Tag of the image",
            "type": "string"
          },
          "user": {
            "description": "user used when executing the command",
            "type": "string"
          }
        },
        "title": "Image",
        "type": "object",
        "x-struct": "Elixir.Kleened.API.Schemas.Image"
      },
      "ImageBuildConfig": {
        "description": "Configuration for an image build.",
        "properties": {
          "buildargs": {
            "default": {},
            "description": "Object of string pairs for build-time ARG-variables. Kleened uses the buildargs as the environment variables for, e.g., the RUN instruction, or for variable expansion in other Dockerfile instructions. This is not meant for passing secret values.",
            "example": {
              "JAIL_MGMT_ENGINE": "kleene",
              "USERNAME": "Stephen"
            },
            "type": "object"
          },
          "cleanup": {
            "default": true,
            "description": "Whether or not to remove the image in case of a build failure.",
            "type": "boolean"
          },
          "context": {
            "description": "Path on the Kleened host of the context that is used for the build.",
            "type": "string"
          },
          "dockerfile": {
            "default": "Dockerfile",
            "description": "Path of the Dockerfile used for the build. The path is relative to the context path.",
            "type": "string"
          },
          "quiet": {
            "default": false,
            "description": "Whether or not to emit status messages of the build process.",
            "type": "boolean"
          },
          "tag": {
            "default": "",
            "description": "A name and optional tag to apply to the image in the name:tag format. If you omit the tag the default latest value is assumed.",
            "type": "string"
          }
        },
        "required": [
          "context"
        ],
        "title": "ImageBuildConfig",
        "type": "object",
        "x-struct": "Elixir.Kleened.API.Schemas.ImageBuildConfig"
      },
      "ImageCreateConfig": {
        "description": "Configuration for the creation of base images.",
        "properties": {
          "autotag": {
            "default": true,
            "description": "Whether or not to auto-genereate a nametag `FreeBSD-<version>:latest` based on `uname(1)`.\n*Method `\"fetch-auto\"` only*.\n",
            "type": "boolean"
          },
          "dns": {
            "default": true,
            "description": "Whether or not to copy `/etc/resolv.conf` from the host to the new image.",
            "type": "boolean"
          },
          "force": {
            "default": false,
            "description": "Ignore any discrepancies detected when using `uname(1)` to fetch the base system.\n*Method `\"fetch-auto\"` only*.\n",
            "type": "boolean"
          },
          "method": {
            "description": "There are four methods for creating a new base image:\n\n- `\"fetch\"`: Fetch a release/snapshot of the base system and use it for image creation.\n- `\"fetch-auto\"`: Automatically fetch a release/snapshot from the offical FreeBSD mirrors, based on information from `uname(1)`.\n- `\"zfs-copy\"`: Create the base image based on a copy of `zfs_dataset`.\n- `\"zfs-clone\"`: Create the base image based on a clone of `zfs_dataset`.\n",
            "enum": [
              "fetch",
              "fetch-auto",
              "zfs-copy",
              "zfs-clone"
            ],
            "type": "string"
          },
          "tag": {
            "default": "",
            "description": "Name and optionally a tag in the `name:tag` format.\n",
            "type": "string"
          },
          "url": {
            "default": "",
            "description": "URL to a remote location where the base system (as a base.txz file) is stored.\n*Method `\"fetch\"` only*.\n",
            "type": "string"
          },
          "zfs_dataset": {
            "default": "",
            "description": "ZFS dataset that the image should be based on.\n*Method `\"zfs-*\"` only*.\n",
            "type": "string"
          }
        },
        "required": [
          "method"
        ],
        "title": "ImageCreateConfig",
        "type": "object",
        "x-struct": "Elixir.Kleened.API.Schemas.ImageCreateConfig"
      },
      "ImageList": {
        "description": "List of images.",
        "items": {
          "$ref": "#/components/schemas/Image"
        },
        "title": "ImageList",
        "type": "array",
        "x-struct": "Elixir.Kleened.API.Schemas.ImageList"
      },
      "MountPoint": {
        "description": "Mount point between some part of the host file system and a container.\nThere are two types of mountpoints:\n\n- `nullfs`: Mount from a user-specified file or directory from the host machine into the container.\n- `volume`: Mount from a Kleene volume into the container.\n",
        "properties": {
          "container_id": {
            "description": "ID of the container that the mountpoint belongs to.",
            "type": "string"
          },
          "destination": {
            "description": "Destination path of the mount within the container.",
            "type": "string"
          },
          "read_only": {
            "description": "Whether this mountpoint is read-only.",
            "type": "boolean"
          },
          "source": {
            "description": "Source used for the mount. Depends on `method`:\n\n- If `method=\"volume\"` then `source` should be a volume name\n- If `method=\"nullfs\"`  then `source` should be a (absolute) path on the host\n",
            "type": "string"
          },
          "type": {
            "description": "Kind of mount: `nullfs` or `volume`.",
            "enum": [
              "volume",
              "nullfs"
            ],
            "type": "string"
          }
        },
        "title": "MountPoint",
        "type": "object",
        "x-struct": "Elixir.Kleened.API.Schemas.MountPoint"
      },
      "MountPointConfig": {
        "description": "Create a mount point between sthe host file system and a container.\n\nThere are two `type`'s of mount points:\n\n- `nullfs`: Mount a user-specified file or directory from the host machine into the container.\n- `volume`: Mount a Kleene volume into the container.\n",
        "properties": {
          "destination": {
            "description": "Destination path of the mount within the container.",
            "type": "string"
          },
          "read_only": {
            "default": false,
            "description": "Whether the mountpoint should be read-only.",
            "type": "boolean"
          },
          "source": {
            "description": "Source used for the mount. Depends on `method`:\n\n- If `method=\"volume\"` then `source` should be a volume name\n- If `method=\"nullfs\"`  then `source` should be a (absolute) path on the host\n",
            "type": "string"
          },
          "type": {
            "description": "Kind of mount to create: `nullfs` or `volume`.",
            "enum": [
              "volume",
              "nullfs"
            ],
            "type": "string"
          }
        },
        "title": "MountPointConfig",
        "type": "object",
        "x-struct": "Elixir.Kleened.API.Schemas.MountPointConfig"
      },
      "Network": {
        "description": "summary description of a network",
        "properties": {
          "bridge_if": {
            "default": "",
            "description": "Name of the bridge interface (used for a 'vnet' network).",
            "type": "string"
          },
          "driver": {
            "description": "Type of network.",
            "type": "string"
          },
          "id": {
            "description": "The id of the network",
            "type": "string"
          },
          "loopback_if": {
            "default": "",
            "description": "Name of the loopback interface (used for a 'loopback' network).",
            "type": "string"
          },
          "name": {
            "description": "Name of the network",
            "type": "string"
          },
          "subnet": {
            "description": "Subnet used for the network",
            "type": "string"
          }
        },
        "title": "Network",
        "type": "object",
        "x-struct": "Elixir.Kleened.API.Schemas.Network"
      },
      "NetworkConfig": {
        "description": "Network configuration",
        "properties": {
          "driver": {
            "description": "Which driver to use for the network. Possible values are 'vnet', 'loopback', and 'host'.\nSee jails(8) and the networking documentation for details.\n",
            "example": "vnet",
            "type": "string"
          },
          "ifname": {
            "description": "Name of the loopback interface that is being used for the network. Only used with the 'loopback' driver.",
            "example": "kleene0",
            "type": "string"
          },
          "name": {
            "description": "Name of the network.",
            "example": "westnet",
            "type": "string"
          },
          "subnet": {
            "description": "The subnet (in CIDR-format) that is used for the network.",
            "example": "10.13.37.0/24",
            "type": "string"
          }
        },
        "required": [
          "name",
          "subnet",
          "driver"
        ],
        "title": "NetworkConfig",
        "type": "object",
        "x-struct": "Elixir.Kleened.API.Schemas.NetworkConfig"
      },
      "NetworkInspect": {
        "description": "Detailed information on a volume.",
        "properties": {
          "network": {
            "$ref": "#/components/schemas/Network"
          },
          "network_endpoints": {
            "description": "Endpoints of the network.",
            "items": {
              "$ref": "#/components/schemas/EndPoint"
            },
            "type": "array"
          }
        },
        "title": "NetworkInspect",
        "type": "object",
        "x-struct": "Elixir.Kleened.API.Schemas.NetworkInspect"
      },
      "NetworkList": {
        "description": "List of networks.",
        "items": {
          "$ref": "#/components/schemas/Network"
        },
        "title": "NetworkList",
        "type": "array",
        "x-struct": "Elixir.Kleened.API.Schemas.NetworkList"
      },
      "Volume": {
        "description": "Volume object used for persistent storage in containers.",
        "properties": {
          "created": {
            "description": "when the volume was created",
            "type": "string"
          },
          "dataset": {
            "description": "underlying zfs dataset of the volume",
            "type": "string"
          },
          "mountpoint": {
            "description": "mountpoint of the volume's underlying zfs-dataset (the mountpoint shown with 'zfs list')",
            "type": "string"
          },
          "name": {
            "description": "Name of the volume",
            "type": "string"
          }
        },
        "title": "Volume",
        "type": "object",
        "x-struct": "Elixir.Kleened.API.Schemas.Volume"
      },
      "VolumeConfig": {
        "description": "Volume configuration",
        "properties": {
          "name": {
            "description": "Name of the volume.",
            "type": "string"
          }
        },
        "required": [
          "name"
        ],
        "title": "VolumeConfig",
        "type": "object",
        "x-struct": "Elixir.Kleened.API.Schemas.VolumeConfig"
      },
      "VolumeInspect": {
        "description": "Detailed information on a volume.",
        "properties": {
          "mountpoints": {
            "description": "Mountpoints of the volume.",
            "items": {
              "$ref": "#/components/schemas/MountPoint"
            },
            "type": "array"
          },
          "volume": {
            "$ref": "#/components/schemas/Volume"
          }
        },
        "title": "VolumeInspect",
        "type": "object",
        "x-struct": "Elixir.Kleened.API.Schemas.VolumeInspect"
      },
      "VolumeList": {
        "description": "List of volumes.",
        "items": {
          "$ref": "#/components/schemas/Volume"
        },
        "title": "VolumeList",
        "type": "array",
        "x-struct": "Elixir.Kleened.API.Schemas.VolumeList"
      },
      "WebSocketMessage": {
        "description": "The request have been validated and the request is being processed.",
        "example": {
          "data": "",
          "message": "succesfully started execution instance in detached mode",
          "msg_type": "closing"
        },
        "properties": {
          "data": {
            "default": "",
            "description": "Any data that might have been created by the process such as an image id.",
            "type": "string"
          },
          "message": {
            "default": "",
            "description": "A useful message to tell the client what has happened.",
            "type": "string"
          },
          "msg_type": {
            "description": "Which type of message.",
            "enum": [
              "starting",
              "closing",
              "error"
            ],
            "type": "string"
          }
        },
        "required": [
          "msg_type",
          "message",
          "data"
        ],
        "title": "WebSocketMessage",
        "type": "object",
        "x-struct": "Elixir.Kleened.API.Schemas.WebSocketMessage"
      }
    }
  },
  "info": {
    "description": "HTTP API for communicating with Kleened",
    "title": "Kleened API",
    "version": "0.0.1"
  },
  "openapi": "3.0.0",
  "paths": {
    "/containers/create": {
      "post": {
        "callbacks": {},
        "deprecated": false,
        "operationId": "Container.Create",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ContainerConfig"
              }
            }
          },
          "description": "Container configuration.",
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdResponse"
                }
              }
            },
            "description": "no error"
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "no such image"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "server error"
          }
        },
        "summary": "container create",
        "tags": []
      }
    },
    "/containers/list": {
      "get": {
        "callbacks": {},
        "deprecated": false,
        "description": "Returns a list of containers. For details on the format, see\n[inspect endpoint](#operation/ContainerInspect) for detailed information\nabout a container.\n\nNote that it uses a different, smaller representation of a container\nthan inspecting a single container.\n",
        "operationId": "Container.List",
        "parameters": [
          {
            "description": "Return all containers. By default, only running containers are shown.",
            "in": "query",
            "name": "all",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContainerSummaryList"
                }
              }
            },
            "description": "no error"
          }
        },
        "summary": "container list",
        "tags": []
      }
    },
    "/containers/prune": {
      "post": {
        "callbacks": {},
        "deprecated": false,
        "description": "Remove all stopped containers.",
        "operationId": "Container.Prune",
        "parameters": [],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdListResponse"
                }
              }
            },
            "description": "no error"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "server error"
          }
        },
        "summary": "container prune",
        "tags": []
      }
    },
    "/containers/{container_id}": {
      "delete": {
        "callbacks": {},
        "deprecated": false,
        "description": "Delete a container.",
        "operationId": "Container.Remove",
        "parameters": [
          {
            "description": "ID or name of the container. An initial segment of the id can be supplied if it uniquely determines the container.",
            "in": "path",
            "name": "container_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdResponse"
                }
              }
            },
            "description": "no error"
          },
          "404": {
            "content": {
              "application/json": {
                "example": {
                  "message": "No such container: df6ed453357b"
                },
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "no such container"
          },
          "409": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "container running"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "server error"
          }
        },
        "summary": "container remove",
        "tags": []
      }
    },
    "/containers/{container_id}/inspect": {
      "get": {
        "callbacks": {},
        "deprecated": false,
        "description": "Inspect a container and its endpoints.",
        "operationId": "Container.Inspect",
        "parameters": [
          {
            "description": "Identifier of the container",
            "in": "path",
            "name": "container_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContainerInspect"
                }
              }
            },
            "description": "container retrieved"
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "no such container"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "server error"
          }
        },
        "summary": "container inspect",
        "tags": []
      }
    },
    "/containers/{container_id}/stop": {
      "post": {
        "callbacks": {},
        "deprecated": false,
        "description": "Stop a container. Alle execution instances running in the container will be shut down.",
        "operationId": "Container.Stop",
        "parameters": [
          {
            "description": "ID or name of the container. An initial segment of the id can be supplied if it uniquely determines the container.",
            "in": "path",
            "name": "container_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdResponse"
                }
              }
            },
            "description": "no error"
          },
          "304": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "container not running"
          },
          "404": {
            "content": {
              "application/json": {
                "example": {
                  "message": "no such container"
                },
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "no such container"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "server error"
          }
        },
        "summary": "container stop",
        "tags": []
      }
    },
    "/containers/{container_id}/update": {
      "post": {
        "callbacks": {},
        "deprecated": false,
        "operationId": "Container.Update",
        "parameters": [
          {
            "description": "ID or name of the container. An initial segment of the id can be supplied if it uniquely determines the container.",
            "in": "path",
            "name": "container_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ContainerConfig"
              }
            }
          },
          "description": "Container configuration.",
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdResponse"
                }
              }
            },
            "description": "no error"
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "no such container"
          },
          "409": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error processing update"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "server error"
          }
        },
        "summary": "container update",
        "tags": []
      }
    },
    "/exec/create": {
      "post": {
        "callbacks": {},
        "deprecated": false,
        "description": "Create an execution instance within a container.",
        "operationId": "Exec.Create",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExecConfig"
              }
            }
          },
          "description": "Configuration to use when creating the execution instance.",
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdResponse"
                }
              }
            },
            "description": "no error"
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "container not found"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "server error"
          }
        },
        "summary": "exec create",
        "tags": []
      }
    },
    "/exec/start": {
      "get": {
        "callbacks": {},
        "deprecated": false,
        "description": "> **Important**: This is a 'dummy' specification since the actual endpoint is websocket-based.\n> Below is a description of the websocket protocol and how it relates to the dummy spec.\n\n## General websocket protocol\nAll of Kleened's websocket endpoints follows a similar pattern, having only differences\nin the contents of the fields in the websocket protocol messages.\nThe specifics of the particular endpoint is described below the general description.\n\nOnce the websocket is established, Kleened expects a configuration-frame, which is given by\nthe request body below. Thus, the contents of request body should be sent as the initial\nframe instead of being contained in the request body.\n\nWhen the config is received, a starting-message is returned, indicating that the process has\nstarted. The starting message, like all protocol messages, follows the schema shown for\nthe 200-response (the WebSocketMessage schema).\nAfter the starting-message, subsequent frames will be 'raw' output from the particular\nprocess being started.\nWhen the process is finished, Kleened closes the websocket with a Close Code 1000 and a\nWebSocketMessage contained in the Close frame's Close Reason.\nThe `msg_type` is always set to `closing` but the contents of the `data` and `message` fields\ndepend on the particular endpoint.\n\nIf the initial configuration message schema is invalid, kleened closes the websocket with\nClose Code 1002 and a WebSocketMessage as the Close frame's Close Reason.\nThe `msg_type` is set to `error` and the contents of the `data` and `message` fields will\ndepend on the specific error.\nThis only happens before the starting-message have been sent to the client.\n\nIf Kleened encounters an error during process execution, Kleened closes the websocket with\nClose Code 1011 and a WebSocketMessage as the Close frame's reason. The `msg_type` is set to\n`error` and the contents of the `data` and `message` fields will depend on the specific error.\n\nIf any unexpected errors/crashes occur during the lifetime of the websocket, Kleend closes\nthe websocket with Close Code 1011 and an empty reason field.\n\n## Endpoint-specific details\nThe following specifics pertain to this endpoint:\n\n\n* The starting-message does not have any content.\n* If the exec-instance is started with `attach: false` the starting-message is followed by a\n  Close frame with Close Code 1001.\n* When the executed process exits the closing-message in the Close frame tells wether the\n  entire container has been stopped or just the exec-instance.\n",
        "operationId": "ExecStartWebSocket",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExecStartConfig"
              }
            }
          },
          "description": "Execution starting configuration.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WebSocketMessage"
                }
              }
            },
            "description": "no error"
          }
        },
        "summary": "exec start",
        "tags": []
      }
    },
    "/exec/{exec_id}/stop": {
      "post": {
        "callbacks": {},
        "deprecated": false,
        "description": "Stop and/or destroy an execution instance.",
        "operationId": "Exec.Stop",
        "parameters": [
          {
            "description": "Id of the execution instance.",
            "in": "path",
            "name": "exec_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Whether or not to force stop the running process (using `kill -9`).",
            "in": "query",
            "name": "force_stop",
            "required": true,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Whether or not to stop the entire container or just the specific execution instance.",
            "in": "query",
            "name": "stop_container",
            "required": true,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdResponse"
                }
              }
            },
            "description": "no error"
          },
          "404": {
            "content": {
              "application/json": {
                "example": {
                  "message": "container not running"
                },
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "no such container"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "server error"
          }
        },
        "summary": "exec stop",
        "tags": []
      }
    },
    "/images/build": {
      "get": {
        "callbacks": {},
        "deprecated": false,
        "description": "> **Important**: This is a 'dummy' specification since the actual endpoint is websocket-based.\n> Below is a description of the websocket protocol and how it relates to the dummy spec.\n\n## General websocket protocol\nAll of Kleened's websocket endpoints follows a similar pattern, having only differences\nin the contents of the fields in the websocket protocol messages.\nThe specifics of the particular endpoint is described below the general description.\n\nOnce the websocket is established, Kleened expects a configuration-frame, which is given by\nthe request body below. Thus, the contents of request body should be sent as the initial\nframe instead of being contained in the request body.\n\nWhen the config is received, a starting-message is returned, indicating that the process has\nstarted. The starting message, like all protocol messages, follows the schema shown for\nthe 200-response (the WebSocketMessage schema).\nAfter the starting-message, subsequent frames will be 'raw' output from the particular\nprocess being started.\nWhen the process is finished, Kleened closes the websocket with a Close Code 1000 and a\nWebSocketMessage contained in the Close frame's Close Reason.\nThe `msg_type` is always set to `closing` but the contents of the `data` and `message` fields\ndepend on the particular endpoint.\n\nIf the initial configuration message schema is invalid, kleened closes the websocket with\nClose Code 1002 and a WebSocketMessage as the Close frame's Close Reason.\nThe `msg_type` is set to `error` and the contents of the `data` and `message` fields will\ndepend on the specific error.\nThis only happens before the starting-message have been sent to the client.\n\nIf Kleened encounters an error during process execution, Kleened closes the websocket with\nClose Code 1011 and a WebSocketMessage as the Close frame's reason. The `msg_type` is set to\n`error` and the contents of the `data` and `message` fields will depend on the specific error.\n\nIf any unexpected errors/crashes occur during the lifetime of the websocket, Kleend closes\nthe websocket with Close Code 1011 and an empty reason field.\n\n## Endpoint-specific details\nThe following specifics pertain to this endpoint:\n\n\n* The `data` field in the starting-message contains the `image_id`.\n* If the build process is successful, the `data` field in the closing-message contains the `image_id` otherwise it contains the latest snapshot or empty string `\"\"` if the build failed before any snapshots have been created.\n",
        "operationId": "ImageBuild",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ImageBuildConfig"
              }
            }
          },
          "description": "Image building configuration.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WebSocketMessage"
                }
              }
            },
            "description": "no error"
          }
        },
        "summary": "image build",
        "tags": []
      }
    },
    "/images/create": {
      "get": {
        "callbacks": {},
        "deprecated": false,
        "description": "> **Important**: This is a 'dummy' specification since the actual endpoint is websocket-based.\n> Below is a description of the websocket protocol and how it relates to the dummy spec.\n\n## General websocket protocol\nAll of Kleened's websocket endpoints follows a similar pattern, having only differences\nin the contents of the fields in the websocket protocol messages.\nThe specifics of the particular endpoint is described below the general description.\n\nOnce the websocket is established, Kleened expects a configuration-frame, which is given by\nthe request body below. Thus, the contents of request body should be sent as the initial\nframe instead of being contained in the request body.\n\nWhen the config is received, a starting-message is returned, indicating that the process has\nstarted. The starting message, like all protocol messages, follows the schema shown for\nthe 200-response (the WebSocketMessage schema).\nAfter the starting-message, subsequent frames will be 'raw' output from the particular\nprocess being started.\nWhen the process is finished, Kleened closes the websocket with a Close Code 1000 and a\nWebSocketMessage contained in the Close frame's Close Reason.\nThe `msg_type` is always set to `closing` but the contents of the `data` and `message` fields\ndepend on the particular endpoint.\n\nIf the initial configuration message schema is invalid, kleened closes the websocket with\nClose Code 1002 and a WebSocketMessage as the Close frame's Close Reason.\nThe `msg_type` is set to `error` and the contents of the `data` and `message` fields will\ndepend on the specific error.\nThis only happens before the starting-message have been sent to the client.\n\nIf Kleened encounters an error during process execution, Kleened closes the websocket with\nClose Code 1011 and a WebSocketMessage as the Close frame's reason. The `msg_type` is set to\n`error` and the contents of the `data` and `message` fields will depend on the specific error.\n\nIf any unexpected errors/crashes occur during the lifetime of the websocket, Kleend closes\nthe websocket with Close Code 1011 and an empty reason field.\n\n## Endpoint-specific details\nThe following specifics pertain to this endpoint:\n\n\n* The starting-message does not have any content.\n* If the image creation process finishes succesfully, the ID of the newly built image is stored in the\n  `data` field of the closing-message.\n",
        "operationId": "ImageCreate",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ImageCreateConfig"
              }
            }
          },
          "description": "Image building configuration.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WebSocketMessage"
                }
              }
            },
            "description": "no error"
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WebSocketMessage"
                }
              }
            },
            "description": "no error"
          }
        },
        "summary": "image create",
        "tags": []
      }
    },
    "/images/list": {
      "get": {
        "callbacks": {},
        "deprecated": false,
        "description": "Returns a list of images on the server. Note that it uses a different, smaller representation of an image than inspecting a single image.",
        "operationId": "Image.List",
        "parameters": [],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ImageList"
                }
              }
            },
            "description": "no error"
          }
        },
        "summary": "image list",
        "tags": []
      }
    },
    "/images/prune": {
      "post": {
        "callbacks": {},
        "deprecated": false,
        "description": "Remove images that are not being used by containers.\n",
        "operationId": "Image.Prune",
        "parameters": [
          {
            "description": "Whether to remove tagged containers as well.",
            "in": "query",
            "name": "all",
            "required": true,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdListResponse"
                }
              }
            },
            "description": "no error"
          }
        },
        "summary": "image prune",
        "tags": []
      }
    },
    "/images/{image_id}": {
      "delete": {
        "callbacks": {},
        "deprecated": false,
        "description": "Remove an image.\n\nImages can't be removed if they have descendant images or are being\nused by a running container.\n",
        "operationId": "Image.Remove",
        "parameters": [
          {
            "description": "ID or name of the image. An initial segment of the id can be supplied if it uniquely determines the image.",
            "in": "path",
            "name": "image_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdResponse"
                }
              }
            },
            "description": "no error"
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "no such image"
          }
        },
        "summary": "image remove",
        "tags": []
      }
    },
    "/images/{image_id}/inspect": {
      "get": {
        "callbacks": {},
        "deprecated": false,
        "description": "Inspect a image and its endpoints.",
        "operationId": "Image.Inspect",
        "parameters": [
          {
            "description": "Identifier of the image",
            "in": "path",
            "name": "image_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Image"
                }
              }
            },
            "description": "image retrieved"
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "no such image"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "server error"
          }
        },
        "summary": "image inspect",
        "tags": []
      }
    },
    "/images/{image_id}/tag": {
      "post": {
        "callbacks": {},
        "deprecated": false,
        "description": "Update the tag of an image.",
        "operationId": "Image.Tag",
        "parameters": [
          {
            "description": "Identifier of the image",
            "in": "path",
            "name": "image_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "New nametag for the image in the `name:tag` format. If `:tag` is omitted, `:latest` is used.",
            "in": "query",
            "name": "nametag",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdResponse"
                }
              }
            },
            "description": "image succesfully tagged"
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "no such image"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "server error"
          }
        },
        "summary": "image tag",
        "tags": []
      }
    },
    "/networks/create": {
      "post": {
        "callbacks": {},
        "deprecated": false,
        "description": "Create a network.",
        "operationId": "Network.Create",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/NetworkConfig"
              }
            }
          },
          "description": "Configuration used for the network.",
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdResponse"
                }
              }
            },
            "description": "no error"
          },
          "409": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "could not create network"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "server error"
          }
        },
        "summary": "network create",
        "tags": []
      }
    },
    "/networks/list": {
      "get": {
        "callbacks": {},
        "deprecated": false,
        "description": "Returns a list of networks. Use [network inspect endpoint](#operation/Network.Inspect)\nfor detailed information about a specific network.\n\nNote that it uses a different, smaller representation of a network than\ninspecting a single network.\n",
        "operationId": "Network.List",
        "parameters": [],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NetworkList"
                }
              }
            },
            "description": "no error"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "server error"
          }
        },
        "summary": "network list",
        "tags": []
      }
    },
    "/networks/prune": {
      "post": {
        "callbacks": {},
        "deprecated": false,
        "description": "Remove all networks that are not being used by any containers.\n",
        "operationId": "Network.Prune",
        "parameters": [],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdListResponse"
                }
              }
            },
            "description": "network removed"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "server error"
          }
        },
        "summary": "network prune",
        "tags": []
      }
    },
    "/networks/{network_id}": {
      "delete": {
        "callbacks": {},
        "deprecated": false,
        "description": "Remove a network. Any connected containers will be disconnected.\n",
        "operationId": "Network.Remove",
        "parameters": [
          {
            "description": "ID or name of the network. An initial segment of the id can be supplied if it uniquely determines the network.",
            "in": "path",
            "name": "network_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdResponse"
                }
              }
            },
            "description": "no error"
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "no such network"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "server error"
          }
        },
        "summary": "network remove",
        "tags": []
      }
    },
    "/networks/{network_id}/connect": {
      "post": {
        "callbacks": {},
        "deprecated": false,
        "description": "Connect a container to a network",
        "operationId": "Network.Connect",
        "parameters": [
          {
            "description": "ID or name of the network. An initial segment of the id can be supplied if it uniquely determines the network.",
            "in": "path",
            "name": "network_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EndPointConfig"
              }
            }
          },
          "description": "Connection configuration.",
          "required": true
        },
        "responses": {
          "204": {
            "description": "operation was succesful"
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "no such network"
          },
          "409": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "operation not possible with the present configuration"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "server error"
          }
        },
        "summary": "network connect",
        "tags": []
      }
    },
    "/networks/{network_id}/disconnect/{container_id}": {
      "post": {
        "callbacks": {},
        "deprecated": false,
        "description": "Disconnect a container from a network.\n\nThe container must be stopped before it can be disconnected.\n",
        "operationId": "Network.Disconnect",
        "parameters": [
          {
            "description": "ID or name of the network. An initial segment of the id can be supplied if it uniquely determines the network.",
            "in": "path",
            "name": "network_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "ID or name of the container. An initial segment of the id can be supplied if it uniquely determines the network.",
            "in": "path",
            "name": "container_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "operation was succesful"
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "no such network and/or container"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "server error"
          }
        },
        "summary": "network disconnect",
        "tags": []
      }
    },
    "/networks/{network_id}/inspect": {
      "get": {
        "callbacks": {},
        "deprecated": false,
        "description": "Inspect a network and its endpoints.",
        "operationId": "Network.Inspect",
        "parameters": [
          {
            "description": "Identifier of the network",
            "in": "path",
            "name": "network_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NetworkInspect"
                }
              }
            },
            "description": "network retrieved"
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "no such network"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "server error"
          }
        },
        "summary": "network inspect",
        "tags": []
      }
    },
    "/volumes/create": {
      "post": {
        "callbacks": {},
        "deprecated": false,
        "description": "Create a volume. The underlying volume zfs dataset will be located at `{kleened root path}/volumes`.",
        "operationId": "Volume.Create",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VolumeConfig"
              }
            }
          },
          "description": "Volume configuration to use when creating the volume",
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdResponse"
                }
              }
            },
            "description": "volume created"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "server error"
          }
        },
        "summary": "volume create",
        "tags": []
      }
    },
    "/volumes/list": {
      "get": {
        "callbacks": {},
        "deprecated": false,
        "description": "Returns a compact listing of existing volumes.",
        "operationId": "Volume.List",
        "parameters": [],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VolumeList"
                }
              }
            },
            "description": "no error"
          }
        },
        "summary": "volume list",
        "tags": []
      }
    },
    "/volumes/prune": {
      "post": {
        "callbacks": {},
        "deprecated": false,
        "description": "Remove all volumes that are not being mounted into any containers.\n",
        "operationId": "Volume.Prune",
        "parameters": [],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdListResponse"
                }
              }
            },
            "description": "volume removed"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "server error"
          }
        },
        "summary": "volume prune",
        "tags": []
      }
    },
    "/volumes/{volume_name}": {
      "delete": {
        "callbacks": {},
        "deprecated": false,
        "description": "Remove one or more volumes. You cannot remove a volume that is in use by a container.\n",
        "operationId": "Volume.Remove",
        "parameters": [
          {
            "description": "Name of the volume",
            "in": "path",
            "name": "volume_name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdResponse"
                }
              }
            },
            "description": "volume removed"
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "no such volume"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "server error"
          }
        },
        "summary": "volume remove",
        "tags": []
      }
    },
    "/volumes/{volume_name}/inspect": {
      "get": {
        "callbacks": {},
        "deprecated": false,
        "description": "Inspect a volume and its mountpoints.",
        "operationId": "Volume.Inspect",
        "parameters": [
          {
            "description": "Name of the volume",
            "in": "path",
            "name": "volume_name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VolumeInspect"
                }
              }
            },
            "description": "volume retrieved"
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "no such volume"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "server error"
          }
        },
        "summary": "volume inspect",
        "tags": []
      }
    }
  },
  "security": [],
  "servers": [],
  "tags": []
}
